<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tennis Rotation Manager - Cloud Sync</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f5f5;
            min-height: 100vh;
            padding: 0;
            margin: 0;
            font-size: 13px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
        }

        .header {
            background: white;
            color: #333;
            padding: 20px 30px;
            text-align: center;
            border-bottom: 3px solid #667eea;
        }

        .header h1 {
            font-size: 22px;
            margin-bottom: 5px;
            color: #667eea;
            font-weight: 700;
        }

        .header p {
            opacity: 0.7;
            font-size: 13px;
            color: #666;
        }

        .nav-tabs {
            display: flex;
            background: white;
            border-bottom: 2px solid #e0e0e0;
            overflow-x: auto;
        }

        .nav-tab {
            flex: 1;
            padding: 12px 15px;
            text-align: center;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            color: #666;
            transition: all 0.2s;
            border-bottom: 3px solid transparent;
            white-space: nowrap;
        }

        .nav-tab:hover {
            background: #f8f9fa;
            color: #333;
        }

        .nav-tab.active {
            color: #667eea;
            border-bottom: 3px solid #667eea;
            background: white;
        }

        .tab-content {
            display: none;
            padding: 20px;
            background: white;
        }

        .tab-content.active {
            display: block;
        }

        .section {
            margin-bottom: 30px;
        }

        .section-title {
            font-size: 16px;
            color: #333;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 2px solid #e0e0e0;
            font-weight: 700;
        }

        .player-input-group {
            display: grid;
            gap: 12px;
            margin-bottom: 20px;
        }

        .player-input {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .player-input label {
            width: 80px;
            font-weight: 600;
            color: #555;
            font-size: 13px;
        }

        .player-input input {
            flex: 1;
            padding: 10px 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 13px;
            transition: border-color 0.3s;
        }

        .player-input input:focus {
            outline: none;
            border-color: #667eea;
        }

        .player-input input:disabled {
            background-color: #f8f9fa;
            color: #495057;
            cursor: not-allowed;
            border-color: #e9ecef;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin-right: 10px;
            margin-bottom: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-success {
            background: #5568d3;
            color: white;
        }

        .btn-success:hover {
            background: #4557bd;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(85, 104, 211, 0.4);
        }

        .btn-danger {
            background: #e85555;
            color: white;
        }

        .btn-danger:hover {
            background: #dc3545;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(220, 53, 69, 0.4);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(108, 117, 125, 0.4);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .sets-container {
            display: grid;
            gap: 20px;
        }

        .set-card {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            border-left: 4px solid #6c757d;
            box-shadow: 0 2px 6px rgba(0,0,0,0.08);
            transition: all 0.3s;
        }

        .set-card:hover {
            box-shadow: 0 3px 10px rgba(0,0,0,0.12);
        }

        .set-card h3 {
            color: #495057;
            margin-bottom: 15px;
            font-size: 18px;
            font-weight: 600;
        }

        .set-card h4 {
            font-size: 14px;
            margin-bottom: 10px;
            color: #333;
            font-weight: 600;
        }

        .bench-selection {
            margin: 15px 0;
        }

        .bench-options {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 12px;
        }

        .bench-option {
            padding: 10px 18px;
            background: white;
            border: 2px solid #ddd;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            font-size: 13px;
            font-weight: 500;
            box-shadow: 0 2px 4px rgba(0,0,0,0.08);
        }

        .bench-option:hover {
            border-color: #667eea;
            transform: translateY(-2px);
        }

        .bench-option.selected {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .bench-option.ineligible {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .bench-option.rank-1 {
            border-color: #667eea;
            background: #e8ecff;
        }

        .bench-option.rank-1.selected {
            background: #667eea;
            color: white;
        }

        .bench-option.rank-2 {
            border-color: #91a0f5;
            background: #f3f5ff;
        }

        .bench-option.rank-2.selected {
            background: #91a0f5;
            color: white;
        }

        .bench-option.rank-3 {
            border-color: #b0b0b0;
            background: #f5f5f5;
        }

        .bench-option.rank-3.selected {
            background: #808080;
            color: white;
        }

        .bench-option.rank-4 {
            border-color: #c0c0c0;
            background: #f8f8f8;
        }

        .bench-option.rank-4.selected {
            background: #999999;
            color: white;
        }

        .bench-option.rank-5 {
            border-color: #d0d0d0;
            background: #fafafa;
        }

        .bench-option.rank-5.selected {
            background: #b0b0b0;
            color: white;
        }

        .rank-badge {
            display: inline-block;
            background: #808080;
            color: white;
            font-size: 10px;
            font-weight: bold;
            padding: 2px 8px;
            border-radius: 10px;
            margin-left: 8px;
        }

        .rank-1 .rank-badge {
            background: #667eea;
            color: white;
        }

        .rank-2 .rank-badge {
            background: #91a0f5;
            color: white;
        }

        .rank-3 .rank-badge {
            background: #808080;
            color: white;
        }

        .rank-4 .rank-badge {
            background: #999999;
            color: white;
        }

        .rank-5 .rank-badge {
            background: #b0b0b0;
            color: white;
        }

        .bench-option.selected .rank-badge {
            background: rgba(255,255,255,0.3);
            color: white;
        }

        .court-display {
            margin: 15px 0;
            padding: 15px;
            background: white;
            border-radius: 5px;
        }

        .court-display h4 {
            color: #555;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .players-on-court {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .player-chip {
            padding: 8px 16px;
            background: #e7f3ff;
            border: 2px solid #667eea;
            border-radius: 20px;
            color: #667eea;
            font-weight: 600;
        }

        .winner-selection {
            margin: 15px 0;
        }

        .winner-options {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .winner-option {
            flex: 1;
            padding: 15px;
            background: white;
            border: 2px solid #ddd;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            font-size: 13px;
        }

        .winner-option:hover {
            border-color: #667eea;
        }

        .winner-option.selected {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .status-message {
            padding: 15px 20px;
            border-radius: 8px;
            margin: 0;
            font-size: 14px;
            font-weight: 500;
        }

        .status-info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .status-success {
            background: #e9ecef;
            color: #495057;
            border: 1px solid #ced4da;
            font-weight: 600;
            font-size: 15px;
        }

        .status-warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeeba;
        }

        .stats-table-wrapper {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            margin-top: 15px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
        }

        .stats-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            margin-top: 0;
            background: white;
            font-size: 13px;
            table-layout: fixed;
        }

        .stats-table th,
        .stats-table td {
            padding: 8px 10px;
            text-align: center;
            border-bottom: 1px solid #e0e0e0;
            font-size: 13px;
            color: #666;
        }

        .stats-table th {
            background: #f5f5f5;
            color: #666;
            font-weight: 600;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .stats-table tbody tr {
            transition: background 0.15s;
            background: white;
        }

        .stats-table tbody tr:last-child td {
            border-bottom: none;
        }

        .stats-table tbody tr:hover td {
            background: #f8f9ff;
        }

        /* Rank column - not sticky */
        .stats-table th:nth-child(1),
        .stats-table td:nth-child(1) {
            width: 8%;
            min-width: 50px;
            font-weight: 700;
            color: #333;
        }

        .stats-table td:nth-child(1) {
            font-size: 0.95em;
        }

        /* FlashScore-style blue badges for rank numbers */
        .stats-table .rank-number {
            display: inline-block;
            min-width: 22px;
            height: 22px;
            line-height: 22px;
            text-align: center;
            font-weight: 700;
            font-size: 10px;
            border-radius: 3px;
        }

        /* Add dot after the number */
        .stats-table .rank-number::after {
            content: '.';
        }

        /* Blue badges for top 5 positions - purple/blue gradient from dark to light */
        .stats-table tbody tr:nth-child(1) .rank-number {
            background: #5568d3;
            color: white;
        }

        .stats-table tbody tr:nth-child(2) .rank-number {
            background: #667eea;
            color: white;
        }

        .stats-table tbody tr:nth-child(3) .rank-number {
            background: #7b8ff0;
            color: white;
        }

        .stats-table tbody tr:nth-child(4) .rank-number {
            background: #91a0f5;
            color: white;
        }

        .stats-table tbody tr:nth-child(5) .rank-number {
            background: #a7b1fa;
            color: white;
        }

        /* FlashScore-style sticky PLAYER column */
        .stats-table th:nth-child(2),
        .stats-table td:nth-child(2) {
            width: 30%;
            min-width: 120px;
            text-align: left;
            padding-left: 15px;
            font-weight: 400;
            position: sticky;
            left: 0;
            z-index: 5;
            background: white;
            border-right: 2px solid #e0e0e0;
            box-shadow: 4px 0 8px -2px rgba(0, 0, 0, 0.1);
        }

        .stats-table th:nth-child(2) {
            background: #f5f5f5;
            z-index: 15;
            font-weight: 600;
            box-shadow: 4px 0 8px -2px rgba(0, 0, 0, 0.1);
        }

        .stats-table tbody tr:hover td:nth-child(2) {
            background: #f0f2ff;
        }

        /* Set columns */
        .stats-table th:nth-child(3),
        .stats-table th:nth-child(4),
        .stats-table th:nth-child(5) {
            width: 10%;
        }

        .stats-table td:nth-child(3),
        .stats-table td:nth-child(4),
        .stats-table td:nth-child(5) {
            width: 10%;
            color: #333;
        }

        /* Total column */
        .stats-table th:nth-child(6),
        .stats-table td:nth-child(6) {
            width: 12%;
            font-weight: 600;
            color: #333;
        }

        /* Points column - darker black with semi-bold like FlashScore */
        .stats-table th:nth-child(7),
        .stats-table td:nth-child(7) {
            width: 20%;
        }

        .stats-table td:nth-child(7) {
            font-weight: 600;
            color: #000;
            font-size: 13px;
        }

        .week-card {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 15px;
            border-left: 4px solid #667eea;
            box-shadow: 0 2px 6px rgba(0,0,0,0.08);
            transition: all 0.3s;
        }

        .week-card:hover {
            box-shadow: 0 3px 10px rgba(0,0,0,0.12);
        }

        .week-card h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 18px;
            font-weight: 600;
        }

        .week-sets {
            display: grid;
            gap: 12px;
        }

        .week-set {
            background: white;
            padding: 12px;
            border-radius: 6px;
            border: 1px solid #e0e0e0;
        }

        .week-set-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .winner-badge {
            background: #667eea;
            color: white;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
        }

        .export-import-section {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
            margin-top: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }

        .file-input-wrapper input[type=file] {
            position: absolute;
            left: -9999px;
        }

        .manual-select {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 1em;
            margin-top: 10px;
            background: white;
            cursor: pointer;
        }

        .manual-select:focus {
            outline: none;
            border-color: #667eea;
        }

        .manual-winner-grid {
            display: grid;
            gap: 10px;
            margin-top: 10px;
        }

        .manual-winner-option {
            padding: 15px;
            background: white;
            border: 2px solid #ddd;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }

        .manual-winner-option:hover {
            border-color: #28a745;
        }

        .manual-winner-option.selected {
            background: #28a745;
            color: white;
            border-color: #28a745;
        }

        .team-builder {
            margin: 15px 0;
            padding: 15px;
            background: white;
            border-radius: 5px;
        }

        .team-builder h4 {
            color: #555;
            margin-bottom: 15px;
        }

        .teams-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .team-box {
            border: 2px solid #6c757d;
            border-radius: 8px;
            padding: 15px;
            background: #f8f9fa;
        }

        .team-box h5 {
            color: #495057;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .player-dropzone {
            min-height: 80px;
            border: 2px dashed #ddd;
            border-radius: 5px;
            padding: 10px;
            background: white;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .player-dropzone.has-players {
            border-style: solid;
            border-color: #6c757d;
        }

        .available-players {
            margin-top: 15px;
        }

        .available-players h5 {
            color: #555;
            margin-bottom: 10px;
        }

        .player-draggable {
            padding: 8px 16px;
            background: #e7f3ff;
            border: 2px solid #667eea;
            border-radius: 20px;
            color: #667eea;
            font-weight: 600;
            cursor: pointer;
            display: inline-block;
            margin: 5px;
            user-select: none;
            transition: all 0.2s;
            font-size: 13px;
        }

        .player-draggable:hover {
            transform: translateY(-2px);
            box-shadow: 0 3px 10px rgba(102, 126, 234, 0.3);
        }

        .player-draggable.in-team {
            background: #667eea;
            color: white;
            cursor: pointer;
        }

        .team-actions {
            margin-top: 15px;
            display: flex;
            gap: 10px;
        }

        .manual-winner-option.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .no-data {
            text-align: center;
            padding: 40px;
            color: #6c757d;
        }

        .no-data-icon {
            font-size: 48px;
            margin-bottom: 15px;
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            .header h1 {
                font-size: 20px;
            }

            .header p {
                font-size: 12px;
            }

            .nav-tab {
                font-size: 11px;
                padding: 10px 5px;
            }

            .tab-content {
                padding: 15px;
            }

            .section-title {
                font-size: 1.2em;
            }

            .player-input {
                flex-direction: column;
                align-items: stretch;
            }

            .player-input label {
                width: 100%;
                margin-bottom: 5px;
            }

            .btn {
                padding: 12px 16px;
                font-size: 0.9em;
                width: 100%;
                margin-bottom: 10px;
            }

            .sets-container {
                gap: 15px;
            }

            .set-card {
                padding: 15px;
            }

            .bench-options {
                flex-direction: column;
            }

            .bench-option {
                width: 100%;
                text-align: left;
            }

            .winner-options {
                flex-direction: column;
            }

            .winner-option {
                width: 100%;
            }

            .teams-grid {
                grid-template-columns: 1fr;
                gap: 10px;
            }

            .team-box {
                padding: 10px;
            }

            .stats-table {
                font-size: 0.85em;
            }

            .stats-table th,
            .stats-table td {
                padding: 10px 8px;
            }

            .stats-table th {
                font-size: 0.75em;
            }

            /* Make table scrollable on mobile */
            .stats-table-wrapper {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }

            /* Rank column - not sticky on mobile */
            .stats-table th:nth-child(1),
            .stats-table td:nth-child(1) {
                min-width: 40px !important;
            }

            /* Enhanced sticky PLAYER column for mobile */
            .stats-table th:nth-child(2),
            .stats-table td:nth-child(2) {
                position: sticky !important;
                left: 0 !important;
                z-index: 5 !important;
                background: white !important;
                border-right: 2px solid #e0e0e0 !important;
                box-shadow: 4px 0 8px -2px rgba(0, 0, 0, 0.1) !important;
                font-weight: 500 !important;
                min-width: 100px !important;
                padding-left: 12px !important;
            }

            .stats-table th:nth-child(2) {
                background: #f5f5f5 !important;
                z-index: 15 !important;
                font-weight: 600 !important;
            }

            .stats-table tbody tr:hover td:nth-child(2) {
                background: #f0f2ff !important;
            }

            .week-card {
                padding: 15px;
            }

            .export-import-section {
                flex-direction: column;
            }

            .export-import-section .btn {
                width: 100%;
            }

            /* Improve touch targets */
            .player-draggable {
                padding: 12px 20px;
                margin: 8px 5px;
                font-size: 1em;
            }

            .bench-option {
                padding: 15px;
                font-size: 1em;
                min-height: 50px;
                display: flex;
                align-items: center;
                justify-content: space-between;
            }

            .rank-badge {
                font-size: 0.8em;
            }

            .stats-table thead th:nth-child(2),
            .stats-table tbody td:nth-child(2) {
                position: sticky;
                left: 8%;
                z-index: 4;
            }
            
            .stats-table thead th:nth-child(2) {
                background: #f5f5f5;
                z-index: 14;
            }
            
            .stats-table tbody td:nth-child(2) {
                background: white;
            }
        }

        @media (max-width: 480px) {
            .header h1 {
                font-size: 1.3em;
            }

            .nav-tabs {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }

            .nav-tab {
                font-size: 0.7em;
                padding: 10px 8px;
                white-space: nowrap;
            }

            .stats-table {
                font-size: 0.75em;
            }

            .bench-visual-cell {
                font-size: 0.8em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéæ Tennis Rotation Manager</h1>
            <p>Fair doubles rotation for 5 players</p>
        </div>

        <div class="nav-tabs">
            <button class="nav-tab active" data-tab="stats">Statistics</button>
            <button class="nav-tab" data-tab="week">Current Week</button>
            <button class="nav-tab" data-tab="history">History</button>
            <button class="nav-tab" data-tab="setup">Setup</button>
            <button class="nav-tab" data-tab="manual">Add Historical Data</button>
            <button class="nav-tab" data-tab="data">Data</button>
        </div>

        <!-- Setup Tab -->
        <div id="setup" class="tab-content">
            <div class="section">
                <h2 class="section-title">Player Setup</h2>
                
                <div style="margin-bottom: 20px;">
                    <button class="btn btn-primary" onclick="toggleEditPlayers()" id="editPlayersBtn">‚úèÔ∏è Edit Players</button>
                    <button class="btn btn-success" onclick="savePlayers()" id="savePlayersBtn" style="display: none;">üíæ Save Players</button>
                    <button class="btn btn-secondary" onclick="cancelEditPlayers()" id="cancelEditBtn" style="display: none;">Cancel</button>
                </div>
                
                <div class="player-input-group">
                    <div class="player-input">
                        <label>Player 1:</label>
                        <input type="text" id="player1" placeholder="Enter name" disabled>
                    </div>
                    <div class="player-input">
                        <label>Player 2:</label>
                        <input type="text" id="player2" placeholder="Enter name" disabled>
                    </div>
                    <div class="player-input">
                        <label>Player 3:</label>
                        <input type="text" id="player3" placeholder="Enter name" disabled>
                    </div>
                    <div class="player-input">
                        <label>Player 4:</label>
                        <input type="text" id="player4" placeholder="Enter name" disabled>
                    </div>
                    <div class="player-input">
                        <label>Player 5:</label>
                        <input type="text" id="player5" placeholder="Enter name" disabled>
                    </div>
                </div>
            </div>
        </div>

        <!-- Current Week Tab -->
        <div id="week" class="tab-content">
            <div class="section">
                <h2 class="section-title">Weekly Match</h2>
                
                <!-- Week Status Card -->
                <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 25px; border-left: 4px solid #667eea;">
                    <div id="weekStatus"></div>
                    <div style="display: flex; gap: 15px; flex-wrap: wrap; margin-top: 15px;">
                        <button class="btn btn-primary" onclick="startNewWeek()" id="newWeekBtn">Start New Week</button>
                        <button class="btn btn-danger" onclick="resetCurrentWeekNoConfirm()" id="resetWeekBtn" style="display: none;">üóëÔ∏è Clear & Restart Week</button>
                    </div>
                </div>
                
                <div id="setsContainer"></div>
            </div>
        </div>

        <!-- Manual Historical Data Tab -->
        <div id="manual" class="tab-content">
            <div class="section">
                <h2 class="section-title">Add Historical Week Data</h2>
                <p style="margin-bottom: 20px; color: #666;">
                    Use this form to manually enter data from previous weeks. This will update player statistics and improve future recommendations.
                </p>

                <div class="set-card">
                    <h3>Week Number</h3>
                    <div class="player-input">
                        <label>Week #:</label>
                        <input type="number" id="manualWeekNumber" min="1" placeholder="Enter week number" style="max-width: 200px;">
                    </div>
                </div>

                <div class="sets-container" id="manualSetsContainer">
                    <!-- Set 1 -->
                    <div class="set-card">
                        <h3>Set 1</h3>
                        <div class="bench-selection">
                            <h4>Bench Player:</h4>
                            <select id="manualSet1Bench" class="manual-select">
                                <option value="">Select player...</option>
                            </select>
                        </div>
                        <div class="winner-selection">
                            <h4>Winning Team:</h4>
                            <div id="manualSet1Winners"></div>
                        </div>
                    </div>

                    <!-- Set 2 -->
                    <div class="set-card">
                        <h3>Set 2</h3>
                        <div class="bench-selection">
                            <h4>Bench Player:</h4>
                            <select id="manualSet2Bench" class="manual-select">
                                <option value="">Select player...</option>
                            </select>
                        </div>
                        <div class="winner-selection">
                            <h4>Winning Team:</h4>
                            <div id="manualSet2Winners"></div>
                        </div>
                    </div>

                    <!-- Set 3 -->
                    <div class="set-card">
                        <h3>Set 3</h3>
                        <div class="bench-selection">
                            <h4>Bench Player:</h4>
                            <select id="manualSet3Bench" class="manual-select">
                                <option value="">Select player...</option>
                            </select>
                        </div>
                        <div class="winner-selection">
                            <h4>Winning Team:</h4>
                            <div id="manualSet3Winners"></div>
                        </div>
                    </div>
                </div>

                <div id="manualStatus" style="margin-top: 20px;"></div>
                <button class="btn btn-success" onclick="saveManualWeek()" style="margin-top: 20px;">
                    üíæ Save Historical Week
                </button>
            </div>
        </div>

        <!-- Statistics Tab -->
        <div id="stats" class="tab-content active">
            <div class="section">
                <h2 class="section-title">Bench Statistics</h2>
                <div id="statsContainer"></div>
            </div>
        </div>

        <!-- History Tab -->
        <div id="history" class="tab-content">
            <div class="section">
                <h2 class="section-title">Match History</h2>
                <div id="historyContainer"></div>
            </div>
        </div>

        <!-- Data Tab -->
        <div id="data" class="tab-content">
            <div class="section">
                <h2 class="section-title">Data Management</h2>
                <p style="margin-bottom: 20px; color: #666;">
                    Your data is automatically saved in your browser's IndexedDB. 
                    Use these tools to backup or restore your data.
                </p>
                
                <div class="export-import-section">
                    <button class="btn btn-success" onclick="exportData()">
                        üì• Export Data (JSON)
                    </button>
                    
                    <button class="btn btn-primary" onclick="document.getElementById('importFile').click()">
                        üì§ Import Data (JSON)
                    </button>
                    <input type="file" id="importFile" accept=".json" onchange="importData(event)" style="display: none;">
                    
                    <button class="btn btn-danger" onclick="clearAllData()">
                        üóëÔ∏è Clear All Data
                    </button>
                </div>

                <div id="dataStatus" style="margin-top: 20px;"></div>
            </div>
        </div>
    </div>

    <script>
        // ==============================================
        // SUPABASE CONFIGURATION
        // ==============================================
        // TODO: Replace these with your actual Supabase credentials
        // Get them from: https://supabase.com ‚Üí Your Project ‚Üí Settings ‚Üí API
        
        const SUPABASE_URL = 'YOUR_SUPABASE_URL_HERE'; // e.g., 'https://xxxxx.supabase.co'
        const SUPABASE_KEY = 'YOUR_SUPABASE_ANON_KEY_HERE'; // Your anon/public key
        
        // Set this to true once you've added your Supabase credentials above
        const SUPABASE_ENABLED = false;
        
        // ==============================================
        // SUPABASE CLIENT (Simple fetch-based)
        // ==============================================
        
        class SupabaseClient {
            constructor(url, key) {
                this.url = url;
                this.key = key;
            }
            
            async query(table, method = 'GET', body = null, id = null) {
                const endpoint = id 
                    ? `${this.url}/rest/v1/${table}?id=eq.${id}`
                    : `${this.url}/rest/v1/${table}`;
                
                const options = {
                    method: method,
                    headers: {
                        'apikey': this.key,
                        'Authorization': `Bearer ${this.key}`,
                        'Content-Type': 'application/json',
                        'Prefer': 'return=representation'
                    }
                };
                
                if (body && (method === 'POST' || method === 'PATCH')) {
                    options.body = JSON.stringify(body);
                }
                
                const response = await fetch(endpoint, options);
                if (!response.ok) {
                    throw new Error(`Supabase error: ${response.statusText}`);
                }
                return response.json();
            }
            
            async getByType(type) {
                const endpoint = `${this.url}/rest/v1/tennis_data?data_type=eq.${type}`;
                const response = await fetch(endpoint, {
                    headers: {
                        'apikey': this.key,
                        'Authorization': `Bearer ${this.key}`
                    }
                });
                const data = await response.json();
                return data.length > 0 ? data[0].content : null;
            }
            
            async upsertByType(type, content) {
                // First, try to get existing
                const existing = await this.getByType(type);
                
                if (existing) {
                    // Update existing
                    const endpoint = `${this.url}/rest/v1/tennis_data?data_type=eq.${type}`;
                    await fetch(endpoint, {
                        method: 'PATCH',
                        headers: {
                            'apikey': this.key,
                            'Authorization': `Bearer ${this.key}`,
                            'Content-Type': 'application/json',
                            'Prefer': 'return=representation'
                        },
                        body: JSON.stringify({
                            content: content,
                            updated_at: new Date().toISOString()
                        })
                    });
                } else {
                    // Insert new
                    const endpoint = `${this.url}/rest/v1/tennis_data`;
                    await fetch(endpoint, {
                        method: 'POST',
                        headers: {
                            'apikey': this.key,
                            'Authorization': `Bearer ${this.key}`,
                            'Content-Type': 'application/json',
                            'Prefer': 'return=representation'
                        },
                        body: JSON.stringify({
                            data_type: type,
                            content: content,
                            updated_at: new Date().toISOString()
                        })
                    });
                }
            }
            
            async getAllWeeks() {
                const weeks = await this.getByType('weeks');
                return weeks || [];
            }
            
            async saveWeeks(weeksArray) {
                await this.upsertByType('weeks', weeksArray);
            }
        }
        
        // Initialize Supabase client (will show error if not configured)
        let supabase = null;
        if (SUPABASE_ENABLED) {
            if (SUPABASE_URL === 'YOUR_SUPABASE_URL_HERE' || SUPABASE_KEY === 'YOUR_SUPABASE_ANON_KEY_HERE') {
                console.error('‚ö†Ô∏è Supabase credentials not configured! Please update SUPABASE_URL and SUPABASE_KEY in the code.');
            } else {
                supabase = new SupabaseClient(SUPABASE_URL, SUPABASE_KEY);
                console.log('‚úÖ Supabase client initialized');
            }
        } else {
            console.log('‚ÑπÔ∏è Supabase disabled - using local IndexedDB storage');
        }

        // Global error handler to prevent console spam
        window.addEventListener('error', function(e) {
            // Silently log errors without showing to user
            console.warn('Caught error:', e.message);
            e.preventDefault();
            return true;
        });

        window.addEventListener('unhandledrejection', function(e) {
            console.warn('Caught promise rejection:', e.reason);
            e.preventDefault();
        });

        // Database management
        let db;
        const DB_NAME = 'TennisRotationDB';
        const DB_VERSION = 1;

        // Initialize IndexedDB
        function initDB() {
            return new Promise((resolve, reject) => {
                try {
                    // Check if IndexedDB is available
                    if (!window.indexedDB) {
                        console.error('IndexedDB not supported');
                        reject(new Error('IndexedDB not supported'));
                        return;
                    }

                    const request = indexedDB.open(DB_NAME, DB_VERSION);

                    request.onerror = (event) => {
                        console.error('Database error:', event);
                        reject(new Error('Failed to open database'));
                    };

                    request.onsuccess = (event) => {
                        db = event.target.result;
                        
                        // Add error handler for database
                        db.onerror = (event) => {
                            console.error('Database error:', event);
                        };
                        
                        console.log('Database initialized successfully');
                        resolve(db);
                    };

                    request.onupgradeneeded = (event) => {
                        try {
                            db = event.target.result;
                            
                            if (!db.objectStoreNames.contains('players')) {
                                db.createObjectStore('players', { keyPath: 'id' });
                            }
                            
                            if (!db.objectStoreNames.contains('weeks')) {
                                db.createObjectStore('weeks', { keyPath: 'weekNumber' });
                            }
                            
                            if (!db.objectStoreNames.contains('currentWeek')) {
                                db.createObjectStore('currentWeek', { keyPath: 'id' });
                            }
                            
                            console.log('Database schema created');
                        } catch (err) {
                            console.error('Error creating database schema:', err);
                            reject(err);
                        }
                    };

                    request.onblocked = () => {
                        console.warn('Database upgrade blocked by another tab');
                    };

                } catch (err) {
                    console.error('Error initializing database:', err);
                    reject(err);
                }
            });
        }

        // Database operations - Unified interface for both Supabase and IndexedDB
        async function saveToStore(storeName, data) {
            try {
                if (SUPABASE_ENABLED && supabase) {
                    // Save to Supabase
                    await supabase.upsertByType(storeName, data);
                    console.log(`‚úÖ Saved to Supabase: ${storeName}`);
                } else {
                    // Save to IndexedDB (fallback)
                    const tx = db.transaction(storeName, 'readwrite');
                    const store = tx.objectStore(storeName);
                    await store.put(data);
                    return await new Promise((resolve, reject) => {
                        tx.oncomplete = () => resolve(true);
                        tx.onerror = () => reject(tx.error);
                    });
                }
            } catch (error) {
                console.error('Error saving to store:', storeName, error);
                throw error;
            }
        }

        async function getFromStore(storeName, key) {
            try {
                if (SUPABASE_ENABLED && supabase) {
                    // Get from Supabase
                    return await supabase.getByType(storeName);
                } else {
                    // Get from IndexedDB (fallback)
                    const tx = db.transaction(storeName, 'readonly');
                    const store = tx.objectStore(storeName);
                    return new Promise((resolve, reject) => {
                        const request = store.get(key);
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                }
            } catch (error) {
                console.error('Error getting from store:', storeName, key, error);
                return null;
            }
        }

        async function getAllFromStore(storeName) {
            try {
                if (SUPABASE_ENABLED && supabase) {
                    // Get from Supabase
                    if (storeName === 'weeks') {
                        return await supabase.getAllWeeks();
                    }
                    return [];
                } else {
                    // Get from IndexedDB (fallback)
                    const tx = db.transaction(storeName, 'readonly');
                    const store = tx.objectStore(storeName);
                    return new Promise((resolve, reject) => {
                        const request = store.getAll();
                        request.onsuccess = () => resolve(request.result || []);
                        request.onerror = () => reject(request.error);
                    });
                }
            } catch (error) {
                console.error('Error getting all from store:', storeName, error);
                return [];
            }
        }

        async function clearStore(storeName) {
            try {
                if (SUPABASE_ENABLED && supabase) {
                    // Clear in Supabase
                    await supabase.upsertByType(storeName, null);
                } else {
                    // Clear in IndexedDB (fallback)
                    const tx = db.transaction(storeName, 'readwrite');
                    const store = tx.objectStore(storeName);
                    await store.clear();
                    return await new Promise((resolve, reject) => {
                        tx.oncomplete = () => resolve(true);
                        tx.onerror = () => reject(tx.error);
                    });
                }
            } catch (error) {
                console.error('Error clearing store:', storeName, error);
                throw error;
            }
        }

        // Tab navigation
        document.querySelectorAll('.nav-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const targetTab = tab.dataset.tab;
                
                document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                
                tab.classList.add('active');
                document.getElementById(targetTab).classList.add('active');
                
                if (targetTab === 'stats') displayStats();
                if (targetTab === 'history') displayHistory();
                if (targetTab === 'week') displayCurrentWeek();
                if (targetTab === 'manual') initManualEntry();
            });
        });

        // Player management
        // Player editing functions
        let originalPlayerValues = [];

        function toggleEditPlayers() {
            // Store original values
            originalPlayerValues = [];
            for (let i = 1; i <= 5; i++) {
                const input = document.getElementById(`player${i}`);
                originalPlayerValues.push(input.value);
                input.disabled = false;
            }

            // Toggle buttons
            document.getElementById('editPlayersBtn').style.display = 'none';
            document.getElementById('savePlayersBtn').style.display = 'inline-block';
            document.getElementById('cancelEditBtn').style.display = 'inline-block';
        }

        function cancelEditPlayers() {
            // Restore original values
            for (let i = 1; i <= 5; i++) {
                const input = document.getElementById(`player${i}`);
                input.value = originalPlayerValues[i - 1];
                input.disabled = true;
            }

            // Toggle buttons back
            document.getElementById('editPlayersBtn').style.display = 'inline-block';
            document.getElementById('savePlayersBtn').style.display = 'none';
            document.getElementById('cancelEditBtn').style.display = 'none';
        }

        async function savePlayers() {
            try {
                const players = [];
                for (let i = 1; i <= 5; i++) {
                    const name = document.getElementById(`player${i}`).value.trim();
                    if (!name) {
                        alert('Please enter all 5 player names');
                        return;
                    }
                    players.push({
                        id: i,
                        name: name,
                        set1Benches: 0,
                        set2Benches: 0,
                        set3Benches: 0,
                        totalBenches: 0
                    });
                }

                await saveToStore('players', { id: 'playerList', players: players });
                
                // Disable inputs and toggle buttons
                for (let i = 1; i <= 5; i++) {
                    document.getElementById(`player${i}`).disabled = true;
                }
                document.getElementById('editPlayersBtn').style.display = 'inline-block';
                document.getElementById('savePlayersBtn').style.display = 'none';
                document.getElementById('cancelEditBtn').style.display = 'none';
                
                alert('Players saved successfully!');
            } catch (error) {
                console.error('Error saving players:', error);
                alert('Error saving players. Please try again.');
            }
        }

        async function loadPlayers() {
            try {
                const data = await getFromStore('players', 'playerList');
                if (data && data.players) {
                    data.players.forEach((player, index) => {
                        const input = document.getElementById(`player${index + 1}`);
                        if (input) {
                            input.value = player.name;
                        }
                    });
                    return data.players;
                }
                return null;
            } catch (error) {
                console.error('Error loading players:', error);
                return null;
            }
        }

        // Week management
        async function startNewWeek() {
            try {
                const players = await loadPlayers();
                if (!players) {
                    alert('Please set up players first!');
                    return;
                }

                const weeks = await getAllFromStore('weeks');
                const weekNumber = weeks.length + 1;

                const currentWeek = {
                    id: 'current',
                    weekNumber: weekNumber,
                    sets: [
                        { number: 1, bench: null, team1: null, team2: null, winners: null, locked: false },
                        { number: 2, bench: null, team1: null, team2: null, winners: null, locked: false },
                        { number: 3, bench: null, team1: null, team2: null, winners: null, locked: false }
                    ],
                    completed: false
                };

                await saveToStore('currentWeek', currentWeek);
                await displayCurrentWeek();
            } catch (error) {
                console.error('Error starting new week:', error);
                alert('Error starting new week. Please try again.');
            }
        }

        // Rank eligible players by fairness algorithm
        function rankPlayersByFairness(eligiblePlayers, setNumber, currentWeek = null) {
            const ranked = [...eligiblePlayers].sort((a, b) => {
                // CRITICAL: Deprioritize players who were already benched THIS WEEK
                // Check if player was benched in Set 1 (when ranking for Set 2 or 3)
                // or in Set 1 or 2 (when ranking for Set 3)
                if (currentWeek) {
                    const aBenchedThisWeek = currentWeek.sets.slice(0, setNumber - 1).some(s => s.bench === a.id);
                    const bBenchedThisWeek = currentWeek.sets.slice(0, setNumber - 1).some(s => s.bench === b.id);
                    
                    // If A was benched this week but B wasn't, B is better
                    if (aBenchedThisWeek && !bBenchedThisWeek) return 1;
                    // If B was benched this week but A wasn't, A is better
                    if (bBenchedThisWeek && !aBenchedThisWeek) return -1;
                    // If both or neither were benched this week, continue with normal fairness
                }

                // Priority 1: Set-specific benches
                if (setNumber === 1) {
                    if (a.set1Benches !== b.set1Benches) {
                        return a.set1Benches - b.set1Benches;
                    }
                } else if (setNumber === 2) {
                    if (a.set2Benches !== b.set2Benches) {
                        return a.set2Benches - b.set2Benches;
                    }
                } else if (setNumber === 3) {
                    if (a.set3Benches !== b.set3Benches) {
                        return a.set3Benches - b.set3Benches;
                    }
                }

                // Priority 2: Set 1 benches (if not already compared)
                if (setNumber !== 1 && a.set1Benches !== b.set1Benches) {
                    return a.set1Benches - b.set1Benches;
                }

                // Priority 3: Set 2 benches (if not already compared)
                if (setNumber !== 2 && a.set2Benches !== b.set2Benches) {
                    return a.set2Benches - b.set2Benches;
                }

                // Priority 4: Set 3 benches (if not already compared)
                if (setNumber !== 3 && a.set3Benches !== b.set3Benches) {
                    return a.set3Benches - b.set3Benches;
                }

                // Priority 5: Total benches
                if (a.totalBenches !== b.totalBenches) {
                    return a.totalBenches - b.totalBenches;
                }

                // Priority 6: Random (stable sort by ID)
                return a.id - b.id;
            });

            return ranked;
        }

        async function displayCurrentWeek() {
            const currentWeek = await getFromStore('currentWeek', 'current');
            const players = await loadPlayers();

            const newWeekBtn = document.getElementById('newWeekBtn');
            const resetWeekBtn = document.getElementById('resetWeekBtn');

            if (!newWeekBtn || !resetWeekBtn) {
                console.error('Week buttons not found in DOM');
                return;
            }

            if (!currentWeek || currentWeek.completed) {
                document.getElementById('weekStatus').innerHTML = 
                    '<div class="status-info">No active week. Start a new week to begin.</div>';
                newWeekBtn.disabled = false;
                newWeekBtn.style.display = 'inline-block';
                resetWeekBtn.style.display = 'none';
                document.getElementById('setsContainer').innerHTML = '';
                return;
            }

            newWeekBtn.disabled = true;
            newWeekBtn.style.display = 'none';
            resetWeekBtn.style.display = 'inline-block';
            resetWeekBtn.disabled = false;
            console.log('Reset button should now be visible');
            document.getElementById('weekStatus').innerHTML = 
                `<div class="status-success">Week ${currentWeek.weekNumber} - In Progress</div>`;

            let html = '<div class="sets-container">';

            for (let i = 0; i < 3; i++) {
                const set = currentWeek.sets[i];
                
                // Progressive display: Only show Set 2 if Set 1 is locked, only show Set 3 if Set 2 is locked
                if (i > 0 && !currentWeek.sets[i-1].locked) {
                    // Don't display this set yet - previous set is not locked
                    break;
                }
                
                // Determine categorization for bench selection
                let winnersLastSet = [];
                let previousBencher = null;
                
                if (i > 0) {
                    // Get winners from previous set
                    winnersLastSet = currentWeek.sets[i-1].winners || [];
                    // Get who was benched in previous set
                    previousBencher = currentWeek.sets[i-1].bench;
                }

                html += `<div class="set-card">
                    <h3>Set ${set.number}</h3>`;

                // Bench selection
                if (!set.locked) {
                    html += `<div class="bench-selection">
                        <h4>Select Bench Player:</h4>
                        <div class="bench-options">`;

                    // For Set 1, rank all players
                    if (i === 0) {
                        const rankedPlayers = rankPlayersByFairness(players, set.number, currentWeek);
                        
                        rankedPlayers.forEach((player, index) => {
                            const isSelected = set.bench === player.id;
                            const rank = index + 1;
                            const rankClass = `rank-${rank}`;
                            let rankLabel = '';
                            
                            if (rank === 1) rankLabel = '1st';
                            else if (rank === 2) rankLabel = '2nd';
                            else if (rank === 3) rankLabel = '3rd';
                            else if (rank === 4) rankLabel = '4th';
                            else if (rank === 5) rankLabel = '5th';
                            
                            html += `<div class="bench-option ${rankClass} ${isSelected ? 'selected' : ''}" 
                                onclick="selectBench(${set.number}, ${player.id})">
                                ${player.name}
                                ${rankLabel ? `<span class="rank-badge">${rankLabel}</span>` : ''}
                            </div>`;
                        });
                    } else {
                        // For Set 2 and 3, categorize by winners/losers/previous bencher
                        // For Set 2 and 3, categorize by winners/losers/previous bencher
                        // Categorize players
                        const losersLastSet = players.filter(p => 
                            !winnersLastSet.includes(p.id) && p.id !== previousBencher
                        );
                        const winnersPlayers = players.filter(p => winnersLastSet.includes(p.id));
                        const previousBencherPlayer = previousBencher ? players.find(p => p.id === previousBencher) : null;

                        // Rank losers by fairness (positions 1-2)
                        const rankedLosers = rankPlayersByFairness(losersLastSet, set.number, currentWeek);
                        
                        // Rank winners by fairness (positions 3-4)
                        const rankedWinners = rankPlayersByFairness(winnersPlayers, set.number, currentWeek);

                        // Display losers first (positions 1-2)
                        rankedLosers.forEach((player, index) => {
                            const isSelected = set.bench === player.id;
                            const rank = index + 1;
                            const rankClass = rank <= 2 ? `rank-${rank}` : '';
                            const rankLabel = rank === 1 ? '1st' : rank === 2 ? '2nd' : '';
                            
                            html += `<div class="bench-option ${rankClass} ${isSelected ? 'selected' : ''}" 
                                onclick="selectBench(${set.number}, ${player.id})">
                                ${player.name}
                                ${rankLabel ? `<span class="rank-badge">${rankLabel}</span>` : ''}
                            </div>`;
                        });

                        // Display winners (positions 3-4)
                        rankedWinners.forEach((player, index) => {
                            const isSelected = set.bench === player.id;
                            const rank = index + 3; // Position 3 or 4
                            const rankClass = `rank-${rank}`;
                            const rankLabel = rank === 3 ? '3rd' : '4th';
                            
                            html += `<div class="bench-option ${rankClass} ${isSelected ? 'selected' : ''}" 
                                onclick="selectBench(${set.number}, ${player.id})">
                                ${player.name}
                                ${rankLabel ? `<span class="rank-badge">${rankLabel}</span>` : ''}
                            </div>`;
                        });

                        // Display previous bencher last (position 5, now clickable)
                        if (previousBencherPlayer) {
                            const isSelected = set.bench === previousBencherPlayer.id;
                            html += `<div class="bench-option rank-5 ${isSelected ? 'selected' : ''}" 
                                onclick="selectBench(${set.number}, ${previousBencherPlayer.id})">
                                ${previousBencherPlayer.name}
                                <span class="rank-badge">5th</span>
                            </div>`;
                        }
                    }

                    html += `</div></div>`;
                }

                // Court display
                if (set.bench !== null) {
                    // Check if both teams are complete (2 players each)
                    const teamsComplete = set.team1 && set.team1.length === 2 && set.team2 && set.team2.length === 2;
                    
                    // Team Builder - show until both teams are complete
                    if (!set.locked && !teamsComplete) {
                        html += `<div class="team-builder">
                            <h4>Build Teams (Click players to assign):</h4>
                            <div class="teams-grid">
                                <div class="team-box">
                                    <h5>Team 1</h5>
                                    <div class="player-dropzone ${set.team1 && set.team1.length === 2 ? 'has-players' : ''}" id="team1-set${set.number}">
                                        ${set.team1 && set.team1.length > 0 ? set.team1.map(id => {
                                            const p = players.find(pl => pl.id === id);
                                            return `<span class="player-draggable in-team" onclick="removeFromTeam(${set.number}, 1, ${id})">${p.name} ‚úï</span>`;
                                        }).join('') : '<span style="color: #999; font-style: italic;">Click 2 players below</span>'}
                                    </div>
                                </div>
                                <div class="team-box">
                                    <h5>Team 2</h5>
                                    <div class="player-dropzone ${set.team2 && set.team2.length === 2 ? 'has-players' : ''}" id="team2-set${set.number}">
                                        ${set.team2 && set.team2.length > 0 ? set.team2.map(id => {
                                            const p = players.find(pl => pl.id === id);
                                            return `<span class="player-draggable in-team" onclick="removeFromTeam(${set.number}, 2, ${id})">${p.name} ‚úï</span>`;
                                        }).join('') : '<span style="color: #999; font-style: italic;">Click 2 players below</span>'}
                                    </div>
                                </div>
                            </div>
                            <div class="available-players">
                                <h5>Available Players (click to add to Team 1 or Team 2):</h5>`;
                        
                        const onCourt = players.filter(p => p.id !== set.bench);
                        const assignedIds = [...(set.team1 || []), ...(set.team2 || [])];
                        const availablePlayers = onCourt.filter(p => !assignedIds.includes(p.id));
                        
                        availablePlayers.forEach(p => {
                            html += `<span class="player-draggable" onclick="addToTeam(${set.number}, ${p.id})">${p.name}</span>`;
                        });
                        
                        if (availablePlayers.length === 0) {
                            html += '<span style="color: #28a745; font-weight: 600;">‚úì All players assigned!</span>';
                        }
                        
                        html += `</div></div>`;
                    }

                    // Display locked teams - only show when BOTH teams have 2 players
                    if (teamsComplete) {
                        const team1Players = set.team1.map(id => players.find(p => p.id === id).name);
                        const team2Players = set.team2.map(id => players.find(p => p.id === id).name);
                        
                        html += `<div class="court-display">
                            <h4>Teams on Court:</h4>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 10px;">
                                <div style="padding: 10px; background: #f8f9fa; border-radius: 5px; border: 2px solid #6c757d;">
                                    <strong style="color: #667eea;">Team 1:</strong><br>
                                    ${team1Players.join(' & ')}
                                </div>
                                <div style="padding: 10px; background: #f8f9fa; border-radius: 5px; border: 2px solid #6c757d;">
                                    <strong style="color: #667eea;">Team 2:</strong><br>
                                    ${team2Players.join(' & ')}
                                </div>
                            </div>
                        </div>`;

                        // Winner selection
                        if (!set.locked) {
                            html += `<div class="winner-selection">
                                <h4>Select Winning Team ${set.number === 3 ? '(Optional for Set 3)' : ''}:</h4>
                                <div class="winner-options">
                                    <div class="winner-option ${set.winners && JSON.stringify(set.winners.sort()) === JSON.stringify([...set.team1].sort()) ? 'selected' : ''}"
                                        onclick="selectWinners(${set.number}, [${set.team1}])">
                                        Team 1: ${team1Players.join(' & ')}
                                    </div>
                                    <div class="winner-option ${set.winners && JSON.stringify(set.winners.sort()) === JSON.stringify([...set.team2].sort()) ? 'selected' : ''}"
                                        onclick="selectWinners(${set.number}, [${set.team2}])">
                                        Team 2: ${team2Players.join(' & ')}
                                    </div>
                                </div>
                            </div>`;

                            // For Set 3, allow locking without winner
                            if (set.number === 3) {
                                html += `<div style="display: flex; gap: 10px; margin-top: 10px;">`;
                                if (set.winners) {
                                    html += `<button class="btn btn-success" onclick="lockSet(${set.number})">Lock Set ${set.number} with Winner</button>`;
                                }
                                html += `<button class="btn btn-secondary" onclick="lockSet(${set.number}, true)">Lock Set ${set.number} - No Winner (Time Limit)</button>
                                </div>`;
                            } else {
                                // Sets 1 and 2 require a winner
                                if (set.winners) {
                                    html += `<button class="btn btn-success" onclick="lockSet(${set.number})">Lock Set ${set.number}</button>`;
                                }
                            }
                        }

                        if (set.locked) {
                            const winnerTeamNum = set.winners ? (JSON.stringify(set.winners.sort()) === JSON.stringify([...set.team1].sort()) ? 1 : 2) : null;
                            const winnerNames = winnerTeamNum ? (winnerTeamNum === 1 ? team1Players.join(' & ') : team2Players.join(' & ')) : null;
                            const benchedPlayerName = set.bench !== null ? players.find(p => p.id === set.bench).name : 'None';
                            html += `<div style="background: #f8f9ff; color: #495057; border: 1px solid #c7d2fe; padding: 15px 20px; border-radius: 8px; margin: 0; font-size: 14px; font-weight: 500;">
                                ‚úì Set locked${winnerNames ? ` - <span style="color: #667eea; font-weight: 600;">Winners: Team ${winnerTeamNum} (${winnerNames})</span>` : ' - No winner (time limit)'} | <span style="color: #6c757d;">Benched: ${benchedPlayerName}</span>
                            </div>`;
                        }
                    }
                } else {
                    html += `<button class="btn btn-primary" onclick="autoSelectBench(${set.number})">
                        Auto-Select Fair Bench
                    </button>`;
                }

                html += `</div>`;
            }

            html += '</div>';

            // Add complete week button
            if (currentWeek.sets.every(s => s.locked)) {
                html += `<button class="btn btn-success" onclick="completeWeek()" style="margin-top: 20px;">
                    Complete Week ${currentWeek.weekNumber}
                </button>`;
            }

            document.getElementById('setsContainer').innerHTML = html;
        }

        async function selectBench(setNumber, playerId) {
            try {
                const currentWeek = await getFromStore('currentWeek', 'current');
                if (!currentWeek) return;
                currentWeek.sets[setNumber - 1].bench = playerId;
                // Reset teams when bench changes
                currentWeek.sets[setNumber - 1].team1 = null;
                currentWeek.sets[setNumber - 1].team2 = null;
                currentWeek.sets[setNumber - 1].winners = null;
                await saveToStore('currentWeek', currentWeek);
                await displayCurrentWeek();
            } catch (error) {
                console.error('Error selecting bench:', error);
            }
        }

        async function addToTeam(setNumber, playerId) {
            try {
                const currentWeek = await getFromStore('currentWeek', 'current');
                if (!currentWeek) return;
                const set = currentWeek.sets[setNumber - 1];

                // Initialize arrays if they don't exist
                if (!set.team1) set.team1 = [];
                if (!set.team2) set.team2 = [];

                // Add to Team 1 if it has space
                if (set.team1.length < 2) {
                    set.team1.push(playerId);
                } 
                // Otherwise add to Team 2 if it has space
                else if (set.team2.length < 2) {
                    set.team2.push(playerId);
                }

                await saveToStore('currentWeek', currentWeek);
                await displayCurrentWeek();
            } catch (error) {
                console.error('Error adding to team:', error);
            }
        }

        async function removeFromTeam(setNumber, teamNumber, playerId) {
            try {
                const currentWeek = await getFromStore('currentWeek', 'current');
                if (!currentWeek) return;
                const set = currentWeek.sets[setNumber - 1];

                if (teamNumber === 1 && set.team1) {
                    set.team1 = set.team1.filter(id => id !== playerId);
                    if (set.team1.length === 0) set.team1 = null;
                } else if (teamNumber === 2 && set.team2) {
                    set.team2 = set.team2.filter(id => id !== playerId);
                    if (set.team2.length === 0) set.team2 = null;
                }

                // Reset winners when teams change
                set.winners = null;

                await saveToStore('currentWeek', currentWeek);
                await displayCurrentWeek();
            } catch (error) {
                console.error('Error removing from team:', error);
            }
        }

        async function autoSelectBench(setNumber) {
            try {
                const players = await loadPlayers();
                const currentWeek = await getFromStore('currentWeek', 'current');
                if (!players || !currentWeek) return;

                // Get winners from previous set and previous bencher
                const winnersLastSet = setNumber > 1 && currentWeek.sets[setNumber - 2].winners ? 
                    currentWeek.sets[setNumber - 2].winners : [];
                const previousBencher = setNumber > 1 ? currentWeek.sets[setNumber - 2].bench : null;

                // Prioritize losers (not winners, not previous bencher)
                const losersPlayers = players.filter(p => 
                    !winnersLastSet.includes(p.id) && p.id !== previousBencher
                );

                // If we have losers available, select the best loser
                if (losersPlayers.length > 0) {
                    const rankedLosers = rankPlayersByFairness(losersPlayers, setNumber, currentWeek);
                    currentWeek.sets[setNumber - 1].bench = rankedLosers[0].id;
                } else {
                    // Fallback: if no losers available, select from winners (should rarely happen)
                    const winnersPlayers = players.filter(p => winnersLastSet.includes(p.id));
                    if (winnersPlayers.length > 0) {
                        const rankedWinners = rankPlayersByFairness(winnersPlayers, setNumber, currentWeek);
                        currentWeek.sets[setNumber - 1].bench = rankedWinners[0].id;
                    }
                }

                await saveToStore('currentWeek', currentWeek);
                await displayCurrentWeek();
            } catch (error) {
                console.error('Error auto-selecting bench:', error);
            }
        }

        async function selectWinners(setNumber, winners) {
            try {
                const currentWeek = await getFromStore('currentWeek', 'current');
                if (!currentWeek) return;
                currentWeek.sets[setNumber - 1].winners = winners;
                await saveToStore('currentWeek', currentWeek);
                await displayCurrentWeek();
            } catch (error) {
                console.error('Error selecting winners:', error);
            }
        }

        async function lockSet(setNumber, noWinner = false) {
            try {
                const currentWeek = await getFromStore('currentWeek', 'current');
                if (!currentWeek) return;
                const set = currentWeek.sets[setNumber - 1];
                
                // For Sets 1 and 2, require a winner
                if (setNumber !== 3 && !set.winners) {
                    alert('Please select a winning team before locking this set.');
                    return;
                }
                
                // For Set 3, allow locking without winner if noWinner flag is true
                if (setNumber === 3 && noWinner) {
                    set.winners = null; // Explicitly set to null for no winner
                }
                
                set.locked = true;
                await saveToStore('currentWeek', currentWeek);
                await displayCurrentWeek();
            } catch (error) {
                console.error('Error locking set:', error);
            }
        }

        async function resetCurrentWeekNoConfirm() {
            console.log('resetCurrentWeekNoConfirm called - NO CONFIRMATION');
            try {
                const currentWeek = await getFromStore('currentWeek', 'current');
                console.log('Current week data:', currentWeek);
                
                if (!currentWeek) {
                    alert('No active week to reset.');
                    return;
                }

                // Clear the current week data WITHOUT confirmation
                console.log('Clearing current week (no confirmation)...');
                await clearStore('currentWeek');
                console.log('Current week cleared successfully');

                // Refresh the display
                console.log('Refreshing display...');
                await displayCurrentWeek();
                console.log('Display refreshed');
                
                // Show brief success message
                console.log('Week reset completed successfully');

            } catch (error) {
                console.error('Error resetting current week:', error);
                alert('‚ùå Error resetting week:\n\n' + error.message + '\n\nPlease try again or refresh the page.');
            }
        }

        async function resetCurrentWeek() {
            console.log('resetCurrentWeek called');
            try {
                const currentWeek = await getFromStore('currentWeek', 'current');
                console.log('Current week data:', currentWeek);
                
                if (!currentWeek) {
                    alert('No active week to reset.');
                    return;
                }

                // More prominent confirmation dialog
                const confirmMessage = 
                    `‚ö†Ô∏è RESET WEEK ${currentWeek.weekNumber}? ‚ö†Ô∏è\n\n` +
                    `This will DELETE all current data:\n` +
                    `‚Ä¢ All bench selections\n` +
                    `‚Ä¢ All team assignments\n` +
                    `‚Ä¢ All winner selections\n\n` +
                    `Historical data will NOT be affected.\n\n` +
                    `Click OK to RESET, or Cancel to keep current week.`;

                const confirmReset = confirm(confirmMessage);

                console.log('User confirmed reset:', confirmReset);

                if (!confirmReset) {
                    console.log('User cancelled reset');
                    return;
                }

                // Clear the current week data
                console.log('Clearing current week...');
                await clearStore('currentWeek');
                console.log('Current week cleared successfully');

                // Refresh the display
                console.log('Refreshing display...');
                await displayCurrentWeek();
                console.log('Display refreshed');
                
                // Show success message AFTER the display has been updated
                setTimeout(() => {
                    alert('‚úÖ Week reset successfully!\n\nYou can now start a new week.');
                }, 100);

            } catch (error) {
                console.error('Error resetting current week:', error);
                alert('‚ùå Error resetting week:\n\n' + error.message + '\n\nPlease try again or refresh the page.');
            }
        }

        async function completeWeek() {
            try {
                const currentWeek = await getFromStore('currentWeek', 'current');
                const players = await loadPlayers();
                if (!currentWeek || !players) return;

                // Update player statistics
                currentWeek.sets.forEach((set, index) => {
                    const player = players.find(p => p.id === set.bench);
                    if (player) {
                        if (index === 0) player.set1Benches++;
                        if (index === 1) player.set2Benches++;
                        if (index === 2) player.set3Benches++;
                        player.totalBenches++;
                    }
                });

                // Save updated players
                await saveToStore('players', { id: 'playerList', players: players });

                // Save completed week
                currentWeek.completed = true;
                await saveToStore('weeks', currentWeek);

                // Clear current week
                await clearStore('currentWeek');

                alert(`Week ${currentWeek.weekNumber} completed!`);
                await displayCurrentWeek();
            } catch (error) {
                console.error('Error completing week:', error);
                alert('Error completing week. Please try again.');
            }
        }

        // Statistics display
        async function displayStats() {
            try {
                const players = await loadPlayers();
                if (!players) {
                    document.getElementById('statsContainer').innerHTML = 
                        '<div class="no-data"><div class="no-data-icon">üìä</div><p>No statistics yet. Set up players and complete some weeks first.</p></div>';
                    return;
                }

                // Calculate weighted bench scores for each player
                // Weights: Set 1 = 1.0, Set 2 = 0.8, Set 3 = 0.6
                const playersWithScores = players.map(player => ({
                    ...player,
                    weightedScore: (player.set1Benches * 1.0) + (player.set2Benches * 0.8) + (player.set3Benches * 0.6)
                }));

                // Sort players by weighted score (descending - highest score first)
                const sortedPlayers = [...playersWithScores].sort((a, b) => {
                    // Priority 1: Weighted score (descending - highest score first)
                    if (a.weightedScore !== b.weightedScore) {
                        return b.weightedScore - a.weightedScore;
                    }
                    // Priority 2: Total benches
                    if (a.totalBenches !== b.totalBenches) {
                        return b.totalBenches - a.totalBenches;
                    }
                    // Priority 3: Name (alphabetical)
                    return a.name.localeCompare(b.name);
                });

                // Calculate max weighted score for proportional display
                const maxWeightedScore = sortedPlayers.length > 0 ? sortedPlayers[0].weightedScore : 0;

                let html = `<div class="stats-table-wrapper"><table class="stats-table">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>Player</th>
                            <th>S1</th>
                            <th>S2</th>
                            <th>S3</th>
                            <th>Total</th>
                            <th>Points</th>
                        </tr>
                    </thead>
                    <tbody>`;

                sortedPlayers.forEach((player, index) => {
                    const rank = index + 1;
                    
                    // Calculate proportion of weighted score (0 to 1)
                    const proportion = maxWeightedScore > 0 ? player.weightedScore / maxWeightedScore : 0;
                    
                    // Create points display (just the weighted score)
                    let pointsDisplay = '';
                    
                    if (player.weightedScore === 0) {
                        pointsDisplay = `<span style="color: #999;">0</span>`;
                    } else {
                        const weightedScoreDisplay = player.weightedScore.toFixed(1);
                        pointsDisplay = `<span style="color: #000; font-weight: 600;">${weightedScoreDisplay}</span>`;
                    }

                    html += `<tr>
                        <td><span class="rank-number">${rank}</span></td>
                        <td>${player.name}</td>
                        <td>${player.set1Benches}</td>
                        <td>${player.set2Benches}</td>
                        <td>${player.set3Benches}</td>
                        <td>${player.totalBenches}</td>
                        <td>${pointsDisplay}</td>
                    </tr>`;
                });

                html += `</tbody></table></div>`;
                html += `<div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 6px; font-size: 0.95em; color: #666;">
                    <strong>Weighted Scoring System:</strong><br>
                    Set 1 benches: <strong>1.0 point</strong> each (most important)<br>
                    Set 2 benches: <strong>0.8 points</strong> each<br>
                    Set 3 benches: <strong>0.6 points</strong> each<br>
                    <br>
                    <strong>Points Column:</strong> Shows the weighted score for each player. Higher points = more deserving to be benched next.<br>
                    <br>
                    <strong>Example:</strong> 1 Set 1 bench = 1.0 pts, 1 Set 2 bench = 0.8 pts, 1 Set 3 bench = 0.6 pts<br>
                    <br>
                    <strong>Ranking:</strong> Players ranked by highest weighted score first
                </div>`;
                
                document.getElementById('statsContainer').innerHTML = html;
            } catch (error) {
                console.error('Error displaying stats:', error);
                document.getElementById('statsContainer').innerHTML = 
                    '<div class="status-warning">Error loading statistics.</div>';
            }
        }

        // History display
        async function displayHistory() {
            const weeks = await getAllFromStore('weeks');
            const players = await loadPlayers();

            if (!weeks || weeks.length === 0) {
                document.getElementById('historyContainer').innerHTML = 
                    '<div class="no-data"><div class="no-data-icon">üìú</div><p>No match history yet. Complete some weeks to see history.</p></div>';
                return;
            }

            let html = '';
            weeks.sort((a, b) => b.weekNumber - a.weekNumber).forEach(week => {
                html += `<div class="week-card">
                    <h3>Week ${week.weekNumber}</h3>
                    <div class="week-sets">`;

                week.sets.forEach(set => {
                    const benchPlayer = players.find(p => p.id === set.bench);
                    
                    let winnerDisplay = '';
                    if (!set.winners) {
                        winnerDisplay = 'No winner (time limit)';
                    } else if (set.team1 && set.team2) {
                        const team1Players = set.team1.map(id => players.find(p => p.id === id).name);
                        const team2Players = set.team2.map(id => players.find(p => p.id === id).name);
                        const isTeam1Winner = JSON.stringify([...set.winners].sort()) === JSON.stringify([...set.team1].sort());
                        winnerDisplay = isTeam1Winner ? 
                            `Team 1: ${team1Players.join(' & ')}` : 
                            `Team 2: ${team2Players.join(' & ')}`;
                    } else {
                        const winnerNames = players.filter(p => set.winners && set.winners.includes(p.id))
                            .map(p => p.name).join(' & ');
                        winnerDisplay = winnerNames;
                    }

                    html += `<div class="week-set">
                        <div class="week-set-header">
                            <span>Set ${set.number}</span>
                            <span class="winner-badge${!set.winners ? '' : ''}">${set.winners ? 'Winners' : 'Result'}: ${winnerDisplay}</span>
                        </div>`;
                    
                    if (set.team1 && set.team2) {
                        const team1Players = set.team1.map(id => players.find(p => p.id === id).name);
                        const team2Players = set.team2.map(id => players.find(p => p.id === id).name);
                        html += `
                            <div style="margin-top: 8px; font-size: 0.9em;">
                                <div>Team 1: ${team1Players.join(' & ')}</div>
                                <div>Team 2: ${team2Players.join(' & ')}</div>
                            </div>`;
                    }
                    
                    html += `<div style="margin-top: 5px;">Bench: <strong>${benchPlayer.name}</strong></div>
                    </div>`;
                });

                html += `</div></div>`;
            });

            document.getElementById('historyContainer').innerHTML = html;
        }

        // Manual historical data entry
        let manualWeekData = {
            set1: { bench: null, team1: null, team2: null, winners: null },
            set2: { bench: null, team1: null, team2: null, winners: null },
            set3: { bench: null, team1: null, team2: null, winners: null }
        };

        async function initManualEntry() {
            const players = await loadPlayers();
            if (!players) {
                document.getElementById('manualStatus').innerHTML = 
                    '<div class="status-warning">Please set up players first in the Setup tab!</div>';
                return;
            }

            // Reset manual data
            manualWeekData = {
                set1: { bench: null, team1: null, team2: null, winners: null },
                set2: { bench: null, team1: null, team2: null, winners: null },
                set3: { bench: null, team1: null, team2: null, winners: null }
            };

            // Populate bench dropdowns
            for (let setNum = 1; setNum <= 3; setNum++) {
                const select = document.getElementById(`manualSet${setNum}Bench`);
                select.innerHTML = '<option value="">Select player...</option>';
                players.forEach(player => {
                    select.innerHTML += `<option value="${player.id}">${player.name}</option>`;
                });

                // Add change listener
                select.addEventListener('change', (e) => {
                    manualWeekData[`set${setNum}`].bench = e.target.value ? parseInt(e.target.value) : null;
                    manualWeekData[`set${setNum}`].team1 = null;
                    manualWeekData[`set${setNum}`].team2 = null;
                    manualWeekData[`set${setNum}`].winners = null;
                    updateManualWinnerOptions(setNum);
                });
            }

            // Initialize winner sections
            for (let setNum = 1; setNum <= 3; setNum++) {
                updateManualWinnerOptions(setNum);
            }

            document.getElementById('manualStatus').innerHTML = '';
        }

        async function updateManualWinnerOptions(setNum) {
            const players = await loadPlayers();
            const benchId = manualWeekData[`set${setNum}`].bench;
            const container = document.getElementById(`manualSet${setNum}Winners`);

            if (!benchId) {
                container.innerHTML = '<p style="color: #999; font-style: italic;">Select a bench player first</p>';
                return;
            }

            const onCourt = players.filter(p => p.id !== parseInt(benchId));
            
            if (onCourt.length !== 4) {
                container.innerHTML = '<p style="color: #999;">Invalid configuration</p>';
                return;
            }

            // Show team builder
            const set = manualWeekData[`set${setNum}`];
            const assignedIds = [...(set.team1 || []), ...(set.team2 || [])];
            const availablePlayers = onCourt.filter(p => !assignedIds.includes(p.id));

            let html = `
                <div class="team-builder" style="margin-top: 10px;">
                    <h5 style="margin-bottom: 10px;">Build Teams:</h5>
                    <div class="teams-grid">
                        <div class="team-box">
                            <h5>Team 1</h5>
                            <div class="player-dropzone ${set.team1 && set.team1.length === 2 ? 'has-players' : ''}">
                                ${set.team1 ? set.team1.map(id => {
                                    const p = players.find(pl => pl.id === id);
                                    return `<span class="player-draggable in-team" onclick="removeFromManualTeam(${setNum}, 1, ${id})">${p.name} ‚úï</span>`;
                                }).join('') : '<span style="color: #999; font-style: italic; font-size: 0.9em;">Click 2 players below</span>'}
                            </div>
                        </div>
                        <div class="team-box">
                            <h5>Team 2</h5>
                            <div class="player-dropzone ${set.team2 && set.team2.length === 2 ? 'has-players' : ''}">
                                ${set.team2 ? set.team2.map(id => {
                                    const p = players.find(pl => pl.id === id);
                                    return `<span class="player-draggable in-team" onclick="removeFromManualTeam(${setNum}, 2, ${id})">${p.name} ‚úï</span>`;
                                }).join('') : '<span style="color: #999; font-style: italic; font-size: 0.9em;">Click 2 players below</span>'}
                            </div>
                        </div>
                    </div>
                    <div style="margin-top: 15px;">
                        <h5 style="margin-bottom: 10px;">Available Players:</h5>`;
            
            availablePlayers.forEach(p => {
                html += `<span class="player-draggable" onclick="addToManualTeam(${setNum}, ${p.id})">${p.name}</span>`;
            });

            if (availablePlayers.length === 0 && set.team1 && set.team2 && set.team1.length === 2 && set.team2.length === 2) {
                html += '<span style="color: #28a745; font-weight: 600;">‚úì All players assigned!</span>';
            }

            html += `</div></div>`;

            // Show winner selection if teams are complete
            if (set.team1 && set.team1.length === 2 && set.team2 && set.team2.length === 2) {
                const team1Players = set.team1.map(id => players.find(p => p.id === id).name);
                const team2Players = set.team2.map(id => players.find(p => p.id === id).name);

                const currentWinners = set.winners;
                const team1Selected = currentWinners && 
                    JSON.stringify([...currentWinners].sort()) === JSON.stringify([...set.team1].sort());
                const team2Selected = currentWinners && 
                    JSON.stringify([...currentWinners].sort()) === JSON.stringify([...set.team2].sort());

                html += `
                    <div style="margin-top: 15px;">
                        <h5>Select Winning Team ${setNum === 3 ? '(Optional for Set 3)' : ''}:</h5>
                        <div class="manual-winner-grid">
                            <div class="manual-winner-option ${team1Selected ? 'selected' : ''}" 
                                onclick="selectManualWinner(${setNum}, [${set.team1}])">
                                Team 1: ${team1Players.join(' & ')}
                            </div>
                            <div class="manual-winner-option ${team2Selected ? 'selected' : ''}" 
                                onclick="selectManualWinner(${setNum}, [${set.team2}])">
                                Team 2: ${team2Players.join(' & ')}
                            </div>
                        </div>`;
                
                // For Set 3, add option to skip winner selection
                if (setNum === 3) {
                    html += `
                        <div style="margin-top: 10px;">
                            <button class="btn btn-secondary" onclick="selectManualWinner(${setNum}, null)" 
                                style="font-size: 0.9em; padding: 8px 16px;">
                                No Winner (Time Limit)
                            </button>
                        </div>`;
                }
                
                html += `</div>`;
            }

            container.innerHTML = html;
        }

        function addToManualTeam(setNum, playerId) {
            const set = manualWeekData[`set${setNum}`];

            // Initialize arrays if they don't exist
            if (!set.team1) set.team1 = [];
            if (!set.team2) set.team2 = [];

            // Add to Team 1 if it has space
            if (set.team1.length < 2) {
                set.team1.push(playerId);
            } 
            // Otherwise add to Team 2 if it has space
            else if (set.team2.length < 2) {
                set.team2.push(playerId);
            }

            updateManualWinnerOptions(setNum);
        }

        function removeFromManualTeam(setNum, teamNumber, playerId) {
            const set = manualWeekData[`set${setNum}`];

            if (teamNumber === 1 && set.team1) {
                set.team1 = set.team1.filter(id => id !== playerId);
                if (set.team1.length === 0) set.team1 = null;
            } else if (teamNumber === 2 && set.team2) {
                set.team2 = set.team2.filter(id => id !== playerId);
                if (set.team2.length === 0) set.team2 = null;
            }

            set.winners = null;
            updateManualWinnerOptions(setNum);
        }

        function selectManualWinner(setNum, winners) {
            manualWeekData[`set${setNum}`].winners = winners;
            updateManualWinnerOptions(setNum);
        }

        async function saveManualWeek() {
            const players = await loadPlayers();
            const weekNumberInput = document.getElementById('manualWeekNumber').value;

            // Validation
            if (!weekNumberInput || weekNumberInput < 1) {
                document.getElementById('manualStatus').innerHTML = 
                    '<div class="status-warning">Please enter a valid week number!</div>';
                return;
            }

            const weekNumber = parseInt(weekNumberInput);

            // Check if all sets have bench and teams
            for (let setNum = 1; setNum <= 3; setNum++) {
                const set = manualWeekData[`set${setNum}`];
                if (!set.bench) {
                    document.getElementById('manualStatus').innerHTML = 
                        `<div class="status-warning">Please select a bench player for Set ${setNum}!</div>`;
                    return;
                }
                if (!set.team1 || set.team1.length !== 2 || !set.team2 || set.team2.length !== 2) {
                    document.getElementById('manualStatus').innerHTML = 
                        `<div class="status-warning">Please assign all players to teams for Set ${setNum}!</div>`;
                    return;
                }
                // Sets 1 and 2 require winners, Set 3 is optional
                if (setNum !== 3 && !set.winners) {
                    document.getElementById('manualStatus').innerHTML = 
                        `<div class="status-warning">Please select the winning team for Set ${setNum}!</div>`;
                    return;
                }
            }

            // Check if week already exists
            const weeks = await getAllFromStore('weeks');
            const existingWeek = weeks.find(w => w.weekNumber === weekNumber);
            
            if (existingWeek) {
                if (!confirm(`Week ${weekNumber} already exists. Do you want to overwrite it?`)) {
                    return;
                }
            }

            // Create week object
            const weekData = {
                weekNumber: weekNumber,
                sets: [
                    { 
                        number: 1, 
                        bench: manualWeekData.set1.bench,
                        team1: manualWeekData.set1.team1,
                        team2: manualWeekData.set1.team2,
                        winners: manualWeekData.set1.winners, 
                        locked: true 
                    },
                    { 
                        number: 2, 
                        bench: manualWeekData.set2.bench,
                        team1: manualWeekData.set2.team1,
                        team2: manualWeekData.set2.team2,
                        winners: manualWeekData.set2.winners, 
                        locked: true 
                    },
                    { 
                        number: 3, 
                        bench: manualWeekData.set3.bench,
                        team1: manualWeekData.set3.team1,
                        team2: manualWeekData.set3.team2,
                        winners: manualWeekData.set3.winners || null, // Allow null for Set 3
                        locked: true 
                    }
                ],
                completed: true,
                manualEntry: true
            };

            // If overwriting, remove old statistics first
            if (existingWeek) {
                existingWeek.sets.forEach((set, index) => {
                    const player = players.find(p => p.id === set.bench);
                    if (player) {
                        if (index === 0) player.set1Benches--;
                        if (index === 1) player.set2Benches--;
                        if (index === 2) player.set3Benches--;
                        player.totalBenches--;
                    }
                });
            }

            // Update player statistics
            weekData.sets.forEach((set, index) => {
                const player = players.find(p => p.id === set.bench);
                if (player) {
                    if (index === 0) player.set1Benches++;
                    if (index === 1) player.set2Benches++;
                    if (index === 2) player.set3Benches++;
                    player.totalBenches++;
                }
            });

            // Save updated players
            await saveToStore('players', { id: 'playerList', players: players });

            // Save week
            await saveToStore('weeks', weekData);

            document.getElementById('manualStatus').innerHTML = 
                `<div class="status-success">‚úì Week ${weekNumber} saved successfully! Statistics updated.</div>`;

            // Clear form
            document.getElementById('manualWeekNumber').value = '';
            manualWeekData = {
                set1: { bench: null, team1: null, team2: null, winners: null },
                set2: { bench: null, team1: null, team2: null, winners: null },
                set3: { bench: null, team1: null, team2: null, winners: null }
            };

            // Reset dropdowns
            for (let setNum = 1; setNum <= 3; setNum++) {
                document.getElementById(`manualSet${setNum}Bench`).value = '';
                document.getElementById(`manualSet${setNum}Winners`).innerHTML = 
                    '<p style="color: #999; font-style: italic;">Select a bench player first</p>';
            }

            alert(`Week ${weekNumber} saved successfully!`);
        }

        // Data export/import
        async function exportData() {
            try {
                console.log('Starting data export...');
                
                const players = await getFromStore('players', 'playerList');
                const weeks = await getAllFromStore('weeks');
                const currentWeek = await getFromStore('currentWeek', 'current');

                console.log('Export data retrieved:', {
                    players: players,
                    weeksCount: weeks ? weeks.length : 0,
                    hasCurrentWeek: !!currentWeek
                });

                // Create export data structure
                const data = {
                    version: 1,
                    exportDate: new Date().toISOString(),
                    players: players || null,
                    weeks: weeks || [],
                    currentWeek: currentWeek || null
                };

                // Show summary before export
                const playerCount = players && players.players ? players.players.length : 0;
                const weeksCount = weeks ? weeks.length : 0;
                const hasCurrentWeek = !!currentWeek;

                console.log('Exporting:', {
                    playerCount: playerCount,
                    completedWeeks: weeksCount,
                    currentWeekInProgress: hasCurrentWeek
                });

                // Create and download the file
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `tennis-rotation-backup-${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                URL.revokeObjectURL(url);

                // Show detailed success message
                document.getElementById('dataStatus').innerHTML = 
                    `<div class="status-success">
                        <strong>‚úì Data exported successfully!</strong><br>
                        <small>
                            Players: ${playerCount} | 
                            Completed weeks: ${weeksCount} | 
                            Current week: ${hasCurrentWeek ? 'Yes' : 'No'}
                        </small>
                    </div>`;
                
                console.log('Export completed successfully');
            } catch (error) {
                console.error('Error exporting data:', error);
                document.getElementById('dataStatus').innerHTML = 
                    `<div class="status-warning">
                        <strong>Error exporting data:</strong><br>
                        ${error.message}
                    </div>`;
            }
        }

        async function importData(event) {
            console.log('Import data triggered');
            const file = event.target.files[0];
            
            if (!file) {
                console.log('No file selected');
                return;
            }

            console.log('File selected:', file.name, 'Size:', file.size, 'bytes');

            // Show loading message
            document.getElementById('dataStatus').innerHTML = 
                '<div class="status-info">‚è≥ Importing data, please wait...</div>';

            const reader = new FileReader();
            
            reader.onerror = () => {
                console.error('FileReader error');
                document.getElementById('dataStatus').innerHTML = 
                    '<div class="status-warning">‚ùå Error reading file. Please try again.</div>';
            };

            reader.onload = async (e) => {
                try {
                    console.log('File read successfully, parsing JSON...');
                    const data = JSON.parse(e.target.result);
                    console.log('JSON parsed successfully:', data);

                    // Validate the data structure
                    if (!data.version) {
                        throw new Error('Invalid backup file: missing version number');
                    }

                    let importedItems = {
                        players: 0,
                        weeks: 0,
                        currentWeek: false
                    };

                    // Import players
                    if (data.players) {
                        console.log('Importing players...');
                        await saveToStore('players', data.players);
                        importedItems.players = data.players.players ? data.players.players.length : 0;
                        console.log('Players imported:', importedItems.players);
                    }

                    // Import weeks
                    if (data.weeks && data.weeks.length > 0) {
                        console.log('Importing weeks...');
                        await clearStore('weeks');
                        for (let week of data.weeks) {
                            await saveToStore('weeks', week);
                            importedItems.weeks++;
                        }
                        console.log('Weeks imported:', importedItems.weeks);
                    }

                    // Import current week
                    if (data.currentWeek) {
                        console.log('Importing current week...');
                        await saveToStore('currentWeek', data.currentWeek);
                        importedItems.currentWeek = true;
                        console.log('Current week imported');
                    }

                    // Reload players into the UI
                    await loadPlayers();
                    await displayCurrentWeek();
                    
                    // Show detailed success message
                    document.getElementById('dataStatus').innerHTML = 
                        `<div class="status-success">
                            <strong>‚úì Data imported successfully!</strong><br>
                            <small>
                                Players: ${importedItems.players} | 
                                Weeks: ${importedItems.weeks} | 
                                Current week: ${importedItems.currentWeek ? 'Yes' : 'No'}
                            </small>
                        </div>`;
                    
                    console.log('Import completed successfully');
                    
                    alert(`‚úì Import successful!\n\nImported:\n‚Ä¢ ${importedItems.players} players\n‚Ä¢ ${importedItems.weeks} completed weeks\n‚Ä¢ Current week: ${importedItems.currentWeek ? 'Yes' : 'No'}`);

                } catch (error) {
                    console.error('Error importing data:', error);
                    document.getElementById('dataStatus').innerHTML = 
                        `<div class="status-warning">
                            <strong>‚ùå Error importing data:</strong><br>
                            <small>${error.message}</small><br>
                            <small>Please check the file format and try again.</small>
                        </div>`;
                    alert('Error importing data:\n\n' + error.message);
                }
            };

            reader.readAsText(file);
            event.target.value = ''; // Clear the input so same file can be selected again
        }

        async function clearAllData() {
            // First confirmation - explain what will be deleted
            const firstConfirm = confirm(
                '‚ö†Ô∏è DANGER: CLEAR ALL DATA ‚ö†Ô∏è\n\n' +
                'This will PERMANENTLY DELETE:\n' +
                '‚úó All 5 player names\n' +
                '‚úó All player statistics (bench counts)\n' +
                '‚úó All completed weeks (history)\n' +
                '‚úó Current week in progress\n' +
                '‚úó EVERYTHING in the app\n\n' +
                '‚ö†Ô∏è Make sure you exported a backup first!\n\n' +
                'Click OK to continue to final confirmation.'
            );

            if (!firstConfirm) {
                document.getElementById('dataStatus').innerHTML = 
                    '<div class="status-info">Clear all data cancelled.</div>';
                return;
            }

            // Second confirmation - make them type to confirm
            const secondConfirm = confirm(
                'üö® FINAL WARNING üö®\n\n' +
                'You are about to delete ALL DATA.\n' +
                'This action CANNOT be undone!\n\n' +
                'Have you exported your data as backup?\n\n' +
                'Click OK to DELETE EVERYTHING\n' +
                'Click Cancel to keep your data safe'
            );

            if (!secondConfirm) {
                document.getElementById('dataStatus').innerHTML = 
                    '<div class="status-info">Clear all data cancelled. Your data is safe.</div>';
                return;
            }

            try {
                // Clear all stores
                await clearStore('players');
                await clearStore('weeks');
                await clearStore('currentWeek');

                // Clear player input fields
                for (let i = 1; i <= 5; i++) {
                    const input = document.getElementById(`player${i}`);
                    if (input) input.value = '';
                }

                document.getElementById('dataStatus').innerHTML = 
                    '<div class="status-success">‚úì All data cleared! The app has been reset.</div>';
                
                await displayCurrentWeek();
                
                alert('All data has been permanently deleted.\n\nYou can now set up new players in the Setup tab.');
            } catch (error) {
                console.error('Error clearing all data:', error);
                document.getElementById('dataStatus').innerHTML = 
                    '<div class="status-warning">Error clearing data: ' + error.message + '</div>';
            }
        }

        // Initialize app
        window.addEventListener('DOMContentLoaded', async () => {
            console.log('App starting...');
            
            try {
                // Show loading state
                const setupTab = document.getElementById('setup');
                if (setupTab) {
                    const loadingDiv = document.createElement('div');
                    loadingDiv.id = 'loadingMessage';
                    loadingDiv.className = 'status-info';
                    loadingDiv.style.margin = '20px';
                    loadingDiv.textContent = 'Loading app...';
                    setupTab.insertBefore(loadingDiv, setupTab.firstChild);
                }

                await initDB();
                console.log('Database initialized');
                
                await loadPlayers();
                console.log('Players loaded');
                
                await displayCurrentWeek();
                console.log('Current week displayed');
                
                await displayStats();
                console.log('Statistics displayed');
                
                // Remove loading message
                const loadingMsg = document.getElementById('loadingMessage');
                if (loadingMsg) {
                    loadingMsg.remove();
                }
                
                console.log('App initialized successfully');
            } catch (error) {
                console.error('Initialization error:', error);
                
                // Show error to user
                const setupTab = document.getElementById('setup');
                if (setupTab) {
                    const loadingMsg = document.getElementById('loadingMessage');
                    if (loadingMsg) {
                        loadingMsg.remove();
                    }
                    
                    const errorDiv = document.createElement('div');
                    errorDiv.className = 'status-warning';
                    errorDiv.style.margin = '20px';
                    errorDiv.innerHTML = `
                        <strong>Error loading app</strong><br>
                        <small>${error.message || 'Unknown error'}</small><br>
                        <small>Try refreshing the page or clearing your browser cache.</small>
                    `;
                    setupTab.insertBefore(errorDiv, setupTab.firstChild);
                }
            }
        });
    </script>
</body>
</html>
